#+startup: content

* General
** System settings

Pseudo-package for Emacs itself.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (use-package-always-ensure t)
    (explicit-shell-file-name "/opt/homebrew/bin/zsh")
    (line-spacing 0.3)
    (world-clock-list '(("America/Los_Angeles" "San Francisco")
                        ("America/New_York" "New York")
                        ("Europe/London" "London")
                        ("Europe/Paris" "Paris")
                        ("Europe/Athens" "Athens"))))
#+end_src

#+BEGIN_SRC emacs-lisp
;; i18n
(prefer-coding-system 'utf-8)

;; Reduce the frequency of garbage collection by making it happen on
;; each 50MB of allocated data (the default is on every 0.76MB)
(setq gc-cons-threshold 50000000)

;; Warn when opening files bigger than 100MB
(setq large-file-warning-threshold 100000000)
#+END_SRC

Auto-saving does not cooperate with org-crypt.el: so you need
to turn it off if you plan to use org-crypt.el quite often.
Otherwise, you'll get an (annoying) message each time you
start Org.

#+begin_src emacs-lisp
  (setq auto-save-default nil)
#+end_src

Emacs might need access to executables that are stored in some custom
locations, for example a Rust tool installed via ~cargo~ or a Python
tool installed via ~pip install --user~.  ~exec-path~ is essentially
the Emacs equivalent of your system's ~$PATH~ and [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]
lets you set the Emacs ~exec-path~ using the same settings as the
shell env.  I also grab the ~ssh-agent~ env vars so that I don't have
to keep entering SSH key passphrases for actions such as pushing Git
changes up to the remote via Magit.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "SSH_AGENT_PID")
    (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")
    (exec-path-from-shell-copy-env "DICPATH"))
#+end_src

Set some defaults

#+BEGIN_SRC emacs-lisp
  (setq-default
   ad-redefinition-action 'accept                   ; Silence warnings for redefinition
   cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
   display-time-default-load-average nil            ; Don't display load average
   help-window-select t                             ; Focus new help windows when opened
   initial-scratch-message ""                       ; Empty the initial *scratch* buffer
   kill-ring-max 128                                ; Maximum length of kill ring
   load-prefer-newer t                              ; Prefers the newest version of a file
   vc-follow-symlinks t                             ; Always follow the symlinks
   view-read-only t                                 ; Always open read-only buffers in view-mode
   calendar-week-start-day 1                        ; Start calendar on Monday not Sunday
   create-lockfiles nil                             ; No lockfiles, don't need them and they mess with Terraform
  )                       


  (cd "~/")                                         ; Start in $HOME
#+END_SRC

Use GNU ~ls~ from the ~coreutils~ package when on macOS.

#+begin_src emacs-lisp
  (when (string= system-type "darwin")
    (setq dired-use-ls-dired t
          insert-directory-program "gls"
          dired-listing-switches "-aBhl --group-directories-first"))
#+end_src

Don't bombard me with elisp compilation warnings when initialising new
or updated packages.

#+begin_src emacs-lisp
  (setq warning-minimum-level :error)
#+end_src

Completion settings, see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Completion-Styles.html][Emacs Docs - Completion Options]] for details.

#+begin_src emacs-lisp
  (setq completion-styles '(substring orderless basic))
  (setq completion-ignore-case t)
  ;; TAB cycle if there are only few candidates
  (setq completion-cycle-threshold 3)
  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete)
#+end_src

Load my custom functions

#+begin_src emacs-lisp
  (use-package custom-functions
    :ensure nil
    :load-path "~/.emacs.d/elisp"
    :config
    (require 'custom-functions))
#+end_src

** Personal information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ross Timson"
      user-mail-address "me@rosstimson.com")
#+END_SRC

** Backups

Put backups in a sensible location rather than scattered all over the place.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

Disk is cheap. Save lots.

#+BEGIN_SRC emacs-lisp
(setq backup-by-copying t)    ; Don't delink hardlings
(setq version-control t)      ; Use version numbers on backups
(setq delete-old-versions t)  ; Automatically delete excess backups
(setq kept-new-versions 20)   ; How many of the newest versions to keep
(setq kept-old-versions 5)    ; How many of the oldest version to keep
#+END_SRC

** Interface

Remove a bunch of cruft from the interface.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t
        inhibit-startup-message t
        inihibt-startup-echo-area-message "rosstimson")
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

Set some further UI options.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (blink-cursor-mode -1)
  (global-hl-line-mode t)
  (line-number-mode t)
  (column-number-mode t)
  (setq-default indicate-empty-lines t)
#+END_SRC

Stop the annoying bloody beeping.

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

Stop resizing the frame all the time and just start emacs maximised.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(default-frame-alist (quote ((fullscreen . maximized)))))
#+END_SRC

Short form yes/no questions.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p #'y-or-n-p)
#+END_SRC

Smooth scrolling.

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 5
      scroll-conservatively 9999
      scroll-step 1)
#+END_SRC

Add my custom colour theme.

#+begin_src emacs-lisp
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
  ;; Currently using modus themes as my default so I can toggle between
  ;; light and dark depending on time of day so don't load my theme by
  ;; default.
  ;;(load-theme 'rosstimson-muted t)
#+end_src

Get other nice themes.

#+BEGIN_SRC emacs-lisp
  (use-package base16-theme)
  (use-package ef-themes)
#+END_SRC

Configure my main theme.

[[https://protesilaos.com/emacs/modus-themes][Modus Themes]] -- Modus Operandi (Light) and Modus Vivendi (Dark)
Accessible themes for GNU Emacs, conforming with the highest standard
for colour contrast between background and foreground values (WCAG
AAA)

#+begin_src emacs-lisp
  (use-package modus-themes
    :demand t
    :bind ("<f5>" . modus-themes-toggle)
    :config
    ;; Customizations should be done prior to loading the themes.
    (setq modus-themes-italic-constructs t
      modus-themes-bold-constructs nil
      modus-themes-region '(accented))

    ;; Settings for the modeline.
    (setq modus-themes-mode-line '(accented borderless padded))

    ;; Rich colours for completion matches.
    (setq modus-themes-completions 'opinionated)

    ;; Make Org mode headings nicer.
    (setq modus-themes-headings
      '((0 . (variable-pitch (height 2.2)))
        (1 . (variable-pitch monochrome (height 2.0)))
        (2 . (variable-pitch monochrome (height 1.7)))
        (3 . (variable-pitch monochrome (height 1.5)))
        (4 . (variable-pitch monochrome (height 1.2)))
        (5 . (variable-pitch monochrome (height 1.0)))
        (t . (variable-pitch monochrome))))

    ;; Important!
    (setq modus-themes-scale-headings t)

    ;; Load the theme of your choice.
    (load-theme 'modus-operandi :no-confirm))
#+end_src

Set a light or dark theme depending on the systems current appearance
which I have set to 'auto' on my Macs meaning they will switch to dark
mode at nighttime.

#+begin_src emacs-lisp
  (defun rt/apply-theme (appearance)
    "Load theme, taking current system APPEARANCE into consideration."
    (mapc #'disable-theme custom-enabled-themes)
    (pcase appearance
      ('light (load-theme 'modus-operandi t))
      ('dark (load-theme 'modus-vivendi t))))

  (add-hook 'ns-system-appearance-change-functions #'rt/apply-theme)
#+end_src

Allow easy movement between windows/splits.

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)
#+END_SRC

** Recent files

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :ensure nil
    :config
    (setq recentf-max-saved-items 50
          recentf-auto-cleanup 100
          recentf-exclude (list "/\\.git/.*\\'" ; Git contents
                                "/elpa/.*\\'"   ; Package files
                                "/elpaca/.*\\'" ; More package files
                                ".*\\.gz\\'"
                                "TAGS"
                                ".*-autoloads\\.el\\'"
                                "/tmp"
                                "/ssh:"
                                "custom\.el"
                                "~/Documents/bookmarks"))
    (recentf-mode t))
#+END_SRC

** iBuffer

Use [[https://www.emacswiki.org/emacs/IbufferMode][ibuffer]] which is a better menu/switcher for buffers.  Most of this
config has been taken from [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][Tips for using Emacs Ibuffer]].

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :ensure nil
  :bind ("C-x C-b" . ibuffer)
  :config
  ;; Don't prompt to delete unmodified buffers.
  (setq ibuffer-expert t)

  ;; Organise ibuffer into groups of related stuff.
  (setq ibuffer-saved-filter-groups
    '(("default"
      ("Dired" (mode . dired-mode))
      ("Org" (or (mode . org-mode)
        (mode . org-agenda-mode)))
      ("Programming" (or (mode . python-ts-mode)
                         (mode . go-mode)
                         (mode . rust-mode)
                         (mode . clojure-ts-mode)))
      ("Shell" (or (mode . eshell-mode)
        (mode . shell-mode)
        (mode . term-mode)))
      ("Magit" (name . "\*magit\*"))
      ("Emacs" (or (name . "^\\*scratch\\*$")
        (name . "^\\*Messages\\*$")
        (name . "^\\*Warnings\\*$")
        (name . "\*Help\*")
        (name . "\*Apropos\*")
        (name . "\*info\*")
        (name . "^\\*anaconda-mode\\*$")
        (mode . ag-mode)))
  )))

  ;; ibuffer-auto-mode is a minor mode that automatically keeps the
  ;; buffer list up to date.
  (add-hook 'ibuffer-mode-hook
            #'(lambda ()
              (ibuffer-auto-mode 1)
              (ibuffer-switch-to-saved-filter-groups "default")))

  ;; Don't show empty filter groups.
  (setq ibuffer-show-empty-filter-groups nil))
#+END_SRC

** Eshell

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :ensure nil
  :commands eshell
  :init
  (setq eshell-aliases-file (concat user-emacs-directory "eshell.aliases")
        eshell-cmpl-ignore-case t
        eshell-history-size 1024)

  ;; Visual commands
  (setq eshell-visual-commands '("vi" "vim" "top" "htop" "less" "more" "tmux"))
  (setq eshell-visual-subcommands '(("git" "log" "diff" "show"))))
#+END_SRC

Make C-l clear eshell screen just as it would a normal shell.

#+BEGIN_SRC emacs-lisp
(defun eshell-clear-buffer ()
  "Clear terminal"
  (interactive)
  (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)))

(add-hook 'eshell-mode-hook
#'(lambda()
  (local-set-key (kbd "C-l") 'eshell-clear-buffer)))
#+END_SRC

** Global Key Bindings

I often split the window and nearly always want to switch to the new
window in order to open a new file.  This will switch automatically so
I don't have the extra step.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x2" (lambda () (interactive)(split-window-vertically) (other-window 1)))
(global-set-key "\C-x3" (lambda () (interactive)(split-window-horizontally) (other-window 1)))
#+END_SRC

Keyboard shortcut for quickly compiling code.

#+begin_src emacs-lisp
  (global-set-key [?\C-x ?c] 'compile)
#+end_src

** Tabs vs Spaces

Default to spaces for indentation.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+END_SRC


* Minor Modes
** Ace-link

Quickly follow links with [[https://github.com/abo-abo/ace-link][Ace-link]].

#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :config
  (ace-link-setup-default)
  (define-key org-mode-map (kbd "M-o") 'ace-link-org))
#+END_SRC

** Age

[[https://github.com/anticomputer/age.el][age.el]] provides transparent [[https://github.com/FiloSottile/age][age]] file encryption and decryption in
Emacs. It is based on the Emacs EasyPG code and offers similar Emacs
file handling for age encrypted files.

Using ~age.el~ you can, for example, maintain ~.org.age~ encrypted Org
files, provide age encrypted authentication information out of
~.authinfo.age~, and open/edit/save age encrypted files via TRAMP.

#+begin_src emacs-lisp
  (use-package age
    :mode ("\\.age\\'" . age-encryption-mode)
    :custom
    (age-default-identity "~/.age/rosstimson.txt")
    ;; My public age key
    (age-default-recipient "age17ll5hultu5gpye40nlj7z7ktcxl8ne9xvtd6udzugkmwlmt83uns82smww")
    :config
    (age-file-enable))
#+end_src

** Aggressive Indent

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode]] - ~electric-indent-mode~ is enough to keep your
code nicely aligned when all you do is type. However, once you start
shifting blocks around, transposing lines, or slurping and barfing
sexps, indentation is bound to go wrong.

~aggressive-indent-mode~ is a minor mode that keeps your code *always*
indented. It reindents after every change, making it more reliable
than ~electric-indent-mode~.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :blackout
    :hook (emacs-lisp-mode . aggressive-indent-mode)
          (clojure-ts-mode . aggressive-indent-mode))
#+end_src

** Apheleia

[[https://github.com/radian-software/apheleia][Apheleia]] - Run code formatter on buffer contents without moving point,
using RCS patches and dynamic programming.

#+begin_src emacs-lisp
  (use-package apheleia
    :blackout
    :init
    (apheleia-global-mode +1)
    :config
    (dolist
        (formatter-cmd '((just-fmt . ("just" "--fmt" "--justfile" filepath))
                         (biome . ("biome" "check" "--stdin-file-path" filepath))))
      (add-to-list #'apheleia-formatters formatter-cmd))

    (setf (alist-get 'python-mode apheleia-mode-alist) '(ruff ruff-isort))
    (setf (alist-get 'python-ts-mode apheleia-mode-alist) '(ruff ruff-isort))
    (setf (alist-get 'just-mode apheleia-mode-alist) '(just-fmt))
    (setf (alist-get 'js-ts-mode apheleia-mode-alist) '(biome))
    (setf (alist-get 'typescript-ts-mode apheleia-mode-alist) '(biome))
    (setf (alist-get 'tsx-ts-mode apheleia-mode-alist) '(biome)))
#+end_src

** Auto Revert

Keep buffers up to date automatically if they are edited by another
program with [[https://emacsdocs.org/docs/emacs/Auto-Revert][Auto Revert]].

#+begin_src emacs-lisp
  (use-package autorevert
    :ensure nil
    :blackout
    :config
    (global-auto-revert-mode t)
    ;; Revert Dired and other buffers
    (setq global-auto-revert-non-file-buffers t)
    ;; Keep vc-mode branch in modeline up to date automatically.
    (setq auto-revert-check-vc-info t))
#+end_src

** Beacon

[[https://github.com/Malabarba/beacon][Beacon]] - A light that follows your cursor around so you don't lose it.

#+begin_src emacs-lisp
  (use-package beacon
    :blackout
    :custom
    (beacon-size 60)
    :config
    (add-to-list 'beacon-dont-blink-major-modes' 'ansi-term)
    (beacon-mode 1))
#+end_src

** Bookmarks

[[https://emacsdocs.org/docs/emacs/Bookmarks][Bookmarks]] - Bookmarks are somewhat like registers in that they record
positions you can jump to. Unlike registers, they have long names, and
they persist automatically from one Emacs session to the next. The
prototypical use of bookmarks is to record where you were reading in
various files.

#+begin_src emacs-lisp
  (use-package bookmark
    :ensure nil
    :defer t
    :custom
    (bookmark-default-file "~/Documents/bookmarks")
    (bookmark-save-flag 1))
#+end_src

** Cape

Cape provides Completion At Point Extensions which can be used in
combination with Corfu, Company or the default completion UI. The
completion backends used by ~completion-at-point~ are so called
~completion-at-point-functions~ (Capfs).

#+begin_src emacs-lisp
  (use-package cape
    ;; Bind dedicated completion commands
    ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    :bind (("C-c p p" . completion-at-point) ;; capf
           ("C-c p t" . complete-tag)        ;; etags
           ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
           ("C-c p h" . cape-history)
           ("C-c p f" . cape-file)
           ("C-c p k" . cape-keyword)
           ("C-c p s" . cape-symbol)
           ("C-c p a" . cape-abbrev)
           ("C-c p l" . cape-line)
           ("C-c p w" . cape-dict)
           ("C-c p \\" . cape-tex)
           ("C-c p _" . cape-tex)
           ("C-c p ^" . cape-tex)
           ("C-c p &" . cape-sgml)
           ("C-c p r" . cape-rfc1345))
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'. The order of the functions matters, the
    ;; first function returning a result wins. Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-elisp-block)
    ;;(add-to-list 'completion-at-point-functions #'cape-history)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    ;;(add-to-list 'completion-at-point-functions #'cape-tex)
    ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
    ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
    (add-to-list 'completion-at-point-functions #'cape-abbrev)
    (add-to-list 'completion-at-point-functions #'cape-dict)
    (add-to-list 'completion-at-point-functions #'cape-symbol)
    ;;(add-to-list 'completion-at-point-functions #'cape-line)
    )
#+end_src

** Consult

[[https://github.com/minad/consult][Consult]] provides various handy commands based on the Emacs completion
function completing-read.  It provides a bunch of helper functions
similar to those found in Counsel and also includes a Swiper-like
function with ~consult-line~.

#+begin_src emacs-lisp
  ;; Example configuration for Consult
  (use-package consult
    ;; Load immediately so I can use recent file search or search stuff on startup.
    :demand t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (("C-x f"   . consult-recent-file)
           ("C-x b"   . consult-buffer)              ;; orig. switch-to-buffer
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("M-y"     . consult-yank-pop)            ;; orig. yank-pop
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g o" . consult-outline)
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-project-imenu)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-find)
           ("M-s L" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch


    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Use `fd' for `consult-find', with the following arguments.
    ;; Ignore case, include hidden, show absolute path, and never colour.
    (setq consult-find-command "fd -i -H -a -c never OPTS ARG"))

  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :bind (:map flycheck-command-map
                ("!" . consult-flycheck)))
#+end_src

** Corfu

[[https://github.com/minad/corfu][Corfu]] enhances in-buffer completion with a small completion popup. The
current candidates are shown in a popup below or above the point. The
candidates can be selected by moving up and down. Corfu is the
minimalistic in-buffer completion counterpart of the Vertico
minibuffer UI.

#+begin_src emacs-lisp
  (use-package corfu
    ;; Optional customizations
    :custom
    (corfu-cycle t)                   ;; Enable cycling for `corfu-next/previous'
    ;; (corfu-auto t)                 ;; Enable auto completion
    (corfu-separator ?\s)             ;; Orderless field separator
    ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
    ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
    ;; (corfu-preview-current nil)    ;; Disable current candidate preview
    ;; (corfu-preselect 'prompt)      ;; Preselect the prompt
    ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
    ;; (corfu-scroll-margin 5)        ;; Use scroll margin

    ;; Enable Corfu only for certain modes.
    ;; :hook ((prog-mode . corfu-mode)
    ;;        (shell-mode . corfu-mode)
    ;;        (eshell-mode . corfu-mode))

    ;; Recommended: Enable Corfu globally.  This is recommended since Dabbrev can
    ;; be used globally (M-/).  See also the customization variable
    ;; `global-corfu-modes' to exclude certain modes.
    :init
    (global-corfu-mode))
#+end_src

** Corfu Nerd Icons

[[https://github.com/LuigiPiucco/nerd-icons-corfu/][nerd-icons-corfu]] - A library for adding icons to completions in
Corfu. It uses nerd-icons.el under the hood and, as such, works on
both GUI and terminal.

#+begin_src emacs-lisp
  (use-package nerd-icons-corfu
    :after corfu
    :init (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

** Crux

[[https://github.com/bbatsov/crux][Crux]] -- A Collection of Ridiculously Useful eXtensions for Emacs.

#+begin_src emacs-lisp
  (use-package crux
    :bind
    ("C-k" . crux-smart-kill-line)
    ("C-x n" . crux-cleanup-buffer-or-region)
    ("C-S-RET" . crux-smart-open-line-above)
    ("S-RET" . crux-smart-open-line)
    ("<C-backspace>" . crux-kill-line-backwards)
    ("C-x C-u" . crux-upcase-region)
    ("C-x C-l" . crux-downcase-region))
#+end_src

** Cut/Copy/Comment

In many editors cut and copy act on the current line if no text is
visually selected, [[https://github.com/purcell/whole-line-or-region/blob/master/whole-line-or-region.el][whole-line-or-region]] does just that for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
   :blackout whole-line-or-region-local-mode
   :config
   (whole-line-or-region-global-mode t))
#+END_SRC

** Dabbrev

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dynamic-Abbrevs.html][Dabbrev]] -- Dynamic Abbreviations

#+begin_src emacs-lisp
  ;; Use Dabbrev with Corfu!
  (use-package dabbrev
    :ensure nil
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . dabbrev-expand))
    ;; Other useful Dabbrev configurations.
    :custom
    (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src

** Dashboard

[[https://github.com/emacs-dashboard/emacs-dashboard][Emacs Dashboard]] An extensible emacs startup screen showing you what’s
most important.

Features:

1. Displays an awesome Emacs banner!
2. Recent files
3. Bookmarks list
4. Recent projects list (Depends on `projectile` or `project.el` package)
5. Org mode agenda
6. Register list
7. Supports both all-the-icons and nerd-icons

#+begin_src emacs-lisp
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-projects-backend 'project-el)

    (dashboard-items '((recents  . 5)
                       (bookmarks . 5)
                       (projects . 5)))


    ;; Value can be
    ;; - nil to display no banner
    ;; - 'official which displays the official emacs logo
    ;; - 'logo which displays an alternative emacs logo
    ;; - 1, 2 or 3 which displays one of the text banners
    ;; - "path/to/your/image.gif", "path/to/your/image.png" or "path/to/your/text.txt" which displays whatever gif/image/text you would prefer
    ;; - a cons of '("path/to/your/image.png" . "path/to/your/text.txt")
    (dashboard-startup-banner 'logo)
    (dashboard-banner-logo-title nil)

    (dashboard-set-footer nil)

    ;; Use icons
    (dashboard-display-icons-p t)
    (dashboard-icon-type 'nerd-icons)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t))
#+end_src

** Denote

[[https://protesilaos.com/emacs/denote][Denote]] is a simple note-taking tool. It is based on the idea that
notes should follow a predictable and descriptive file-naming
scheme. The file name must offer a clear indication of what the note
is about, without reference to any other metadata. Denote basically
streamlines the creation of such files while providing facilities to
link between them.

#+begin_src emacs-lisp
  (use-package denote
    :hook (dired-mode . denote-dired-mode-in-directories)
    :bind
    ("C-c n n" . denote)
    ("C-c n N" . denote-type)
    ("C-c n d" . denote-date)
    ("C-c n s" . denote-subdirectory)
    ("C-c n t" . denote-template)
    ("C-c n i" . denote-link)
    ("C-c n I" . denote-link-add-links)
    ("C-c n l" . denote-link-find-file)
    ("C-c n b" . denote-link-backlinks)
    ("C-c n r" . denote-rename-file)
    ("C-c n R" . denote-rename-file-using-front-matter)
    :config
    (setq denote-directory (expand-file-name "~/Documents/notes/"))
    (setq denote-infer-keywords t)
    (setq denote-sort-keywords t)
    (setq denote-prompts '(title keywords subdirectory))
    :custom
    (denote-known-keywords '("emacs" "programming" "sre")))
#+end_src

** Diff-hl

[[https://github.com/dgutov/diff-hl][diff-hl]] - Highlights uncommitted changes in the gutter.

#+begin_src emacs-lisp
  (use-package diff-hl
    :config
    (global-diff-hl-mode))
#+end_src

** Dired

Dired is the directory listing / file manager.  When on BSD it will
complain: 'ls does not support --dired', rather than installing GNU
Coreutils just for this just work around it with very minor
limitations.

#+BEGIN_SRC emacs-lisp
  (when (string= system-type "berkeley-unix")
    (setq dired-use-ls-dired nil))
#+END_SRC

Use human readable file sizes.

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches
        "-l --all --human-readable --group-directories-first")
#+END_SRC

Allow visiting of files via 'a' key which won't create multiple Dired
buffers for each dir visited, this is disabled by default and a
warning message will appear.

#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

** Dirvish

[[https://github.com/alexluigit/dirvish][Dirvish]] is a modern replacement for Dired.

Install [[https://github.com/rainstormstudio/nerd-icons.el][nerd-icons]] first to use with Dirvish.

#+begin_src emacs-lisp
  (use-package nerd-icons)
#+end_src

#+begin_src emacs-lisp
  (use-package dirvish
    :init
    (dirvish-override-dired-mode)
    :custom
    (dirvish-quick-access-entries
     '(("h" "~/"              "Home")
       ("c" "~/code/"         "Code")
       ("." "~/.dotfiles/"    "Dotfiles")
       ("d" "~/Downloads/"    "Downloads")
       ("w" "~/code/work/"    "Work")
       ))
    (dirvish-attributes
     '(nerd-icons file-time file-size collapse subtree-state))
    (delete-by-moving-to-trash t)
    :bind ; Bind `dirvish|dirvish-side|dirvish-dwim' as you see fit
    (("C-c f" . dirvish-fd)
     :map dirvish-mode-map ; Dirvish inherits `dired-mode-map'
     ("a"   . dirvish-quick-access)
     ("f"   . dirvish-file-info-menu)
     ("y"   . dirvish-yank-menu)
     ("N"   . dirvish-narrow)
     ("^"   . dirvish-history-last)
     ("h"   . dirvish-history-jump) ; remapped `describe-mode'
     ("s"   . dirvish-quicksort)    ; remapped `dired-sort-toggle-or-edit'
     ("v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
     ("TAB" . dirvish-subtree-toggle)
     ("M-f" . dirvish-history-go-forward)
     ("M-b" . dirvish-history-go-backward)
     ("M-l" . dirvish-ls-switches-menu)
     ("M-m" . dirvish-mark-menu)
     ("M-t" . dirvish-layout-toggle)
     ("M-s" . dirvish-setup-menu)
     ("M-e" . dirvish-emerge-menu)
     ("M-j" . dirvish-fd-jump)))
#+end_src

** Dumb Jump

[[https://github.com/jacktasia/dumb-jump][Dump Jump]] allows you to jump to definition similar to Etags but without the
extra config and need for tag files.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :config
    (setq dumb-jump-default-project "~/code"
          dumb-jump-selector 'completing-read
          dumb-jump-prefer-searcher 'rg)
    :hook (xref-backend-functions . dumb-jump-xref-activate))
#+END_SRC

** Eglot

[[https://joaotavora.github.io/eglot/][Eglot]] is the Emacs client for the Language Server Protocol (LSP), it
is included by default with Emacs since version 29.1.

#+begin_src emacs-lisp
  ;; Needed so it updates as latest eglot needs a newer version than the
  ;; builtin version.
  (use-package jsonrpc)

  (use-package eglot
    ;;:ensure nil
    :bind (:map eglot-mode-map
                ("M-." . xref-find-definitions)
                ("C-c h" . eglot-help-at-point))
    :hook ((bash-ts-mode . eglot-ensure)
           (clojure-ts-mode . eglot-ensure)
           (go-mode . eglot-ensure)
           (javascript-ts-mode. eglot-ensure)
           (python-ts-mode . eglot-ensure)
           (rust-mode . eglot-ensure)
           (terraform-mode . eglot-ensure)
           (typescript-ts-mode . eglot-ensure))
    :config
    (add-to-list 'eglot-server-programs
                 '(terraform-mode . ("terraform-ls" "serve"))))
#+end_src

*** Eglot Orderless

#+begin_src emacs-lisp
  (use-package eglot-orderless
    :ensure nil
    :no-require t
    :after (eglot orderless)
    :config
    (add-to-list 'completion-category-overrides
                 '(eglot (styles orderless basic))))
#+end_src

** ElDoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :blackout)
#+END_SRC

** Embark

[[https://github.com/oantolin/embark/][Embark]] is minibuffer actions rooted in keymaps which provides a sort
of right-click contextual menu for Emacs, accessed through the
embark-act command (which you should bind to a convenient key),
offering you relevant actions to use on a target determined by the
context:

#+begin_src emacs-lisp
  (use-package embark
    :bind
    ("C-S-a" . embark-act))

  ;; Consult integration.
  (use-package embark-consult
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

** Emmet

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind ("C-<return>" . emmet-expand-line)
  :config
  (add-hook 'web-mode-hook 'emmet-mode)
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'html-mode-hook 'emmet-mode))
#+END_SRC

** Flycheck

[[https://www.flycheck.org/en/latest/index.html][Flycheck]] is a modern on-the-fly syntax checking extension for GNU
Emacs, intended as replacement for the older Flymake extension which
is part of GNU Emacs.

#+begin_src emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))
#+end_src

[[https://github.com/intramurz/flycheck-eglot][flycheck-eglot]] - A simple “glue” minor mode that allows Flycheck and
Eglot to work together. Thus, the Flycheck frontend can display the
results of syntactic checks performed by the LSP server.

Note that Eglot the Emacs built-in LSP package works with Flymake by
default, this package disables Flymake in favour of Flycheck which is
more capable.

#+begin_src emacs-lisp
  (use-package flycheck-eglot
    :after (flycheck eglot)
    :config
    (global-flycheck-eglot-mode 1))
#+end_src

** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] - Can be used to tie related commands into a family of short
bindings with a common prefix - a Hydra.

The Smerge Hydra has been pinched from [[https://github.com/alphapapa/unpackaged.el][unpackaged.el]], I couldn't get
it to work in the ~:config~ of Smerge but seems fine here and it kinda
makes sense to keep all Hydras here.

#+begin_src emacs-lisp
  (use-package hydra
    :config
    (defhydra hydra-zoom (global-map "C-x r z")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out")
      ("q" nil "cancel"))

    (defhydra smerge-hydra
      (:color pink :hint nil :post (smerge-auto-leave))
      "
  ^Move^       ^Keep^               ^Diff^                 ^Other^
  ^^-----------^^-------------------^^---------------------^^-------
  _n_ext       _b_ase               _<_: upper/base        _C_ombine
  _p_rev       _u_pper / mine       _=_: upper/lower       _r_esolve
  ^^           _l_ower / other      _>_: base/lower        _k_ill current
  ^^           _a_ll                _R_efine
  ^^           _RET_: current       _E_diff
  "
      ("n" smerge-next)
      ("p" smerge-prev)
      ("b" smerge-keep-base)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("RET" smerge-keep-current)
      ("\C-m" smerge-keep-current)
      ("<" smerge-diff-base-upper)
      ("=" smerge-diff-upper-lower)
      (">" smerge-diff-base-lower)
      ("R" smerge-refine)
      ("E" smerge-ediff)
      ("C" smerge-combine-with-next)
      ("r" smerge-resolve)
      ("k" smerge-kill-current)
      ("ZZ" (lambda ()
              (interactive)n
              (save-buffer)
              (bury-buffer))
       "Save and bury buffer" :color blue)
      ("q" nil "cancel" :color blue)))
#+end_src

** Iedit

Edit multiple regions in the same way simultaneously with [[https://github.com/victorhge/iedit][Iedit]].

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :commands (iedit-mode iedit-rectangle-mode)
  :bind ("C-;" . iedit-mode))
#+END_SRC

** Magit

[[https://magit.vc/][Magit]] the one and only Git frontend.

#+begin_src emacs-lisp
  (use-package magit
    ;; Don't lazy load, force loading to occur immediately and not
    ;; establish an autoload for the bound key.  I do this so that Magit
    ;; is around whent git committing from terminal via emacsclient,
    ;; without it magit does not get loaded and you edit the commit
    ;; message without magit's extras.
    :demand t
    :bind ("C-c g" . magit-status)
    :hook
    ;; Refresh diff-hl status after committing changes in Magit.
    (magit-pre-refresh  . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh))
#+end_src

[[https://magit.vc/manual/forge.html][Forge]] allows you to work with Git forges, such as Github and Gitlab,
from the comfort of Magit and the rest of Emacs.

#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :custom
    (forge-topic-list-limit '(60 . 0) "Maximum of 60 open topics and 0 closed topics."))
#+end_src

** Marginalia

Enable richer annotations using the [[https://github.com/minad/marginalia/][Marginalia]] package, this shows
short explanations next to items in the minibuffer.

#+begin_src emacs-lisp
  (use-package marginalia
    ;; Either bind `marginalia-cycle` globally or only in the minibuffer
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode)

    ;; Prefer richer, more heavy, annotations over the lighter default variant.
    ;; E.g. M-x will show the documentation string additional to the keybinding.
    ;; By default only the keybinding is shown as annotation.
    ;; Note that there is the command `marginalia-cycle' to
    ;; switch between the annotators.
    ;; (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  )
#+end_src

** Orderless

[[https://github.com/oantolin/orderless][Orderless]] completion style that divides the pattern into
space-separated components, and matches candidates that match all of
the components in any order. Each component can match in any one of
several ways: literally, as a regexp, as an initialism, in the flex
style, or as multiple word prefixes. By default, regexp and literal
matches are enabled.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Rainbow delimiters

Highlight parens etc. by depth with [[https://www.emacswiki.org/emacs/RainbowDelimiters][Rainbow Delimiters]].

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Ripgrep

[[https://github.com/dajva/rg.el][rg.el]] - Use ripgrep in Emacs.

Ripgrep is my search tool of choice and has essentially completely
replaced ~grep~ for me.

Ripgrep is a replacement for both grep like (search one file) and ag
like (search many files) tools. It's fast and versatile and written in
Rust.

#+begin_src emacs-lisp
  (use-package rg
    :config
    (rg-enable-default-bindings))
#+end_src

** Sly

[[https://github.com/joaotavora/sly][SLY]] is Sylvester the Cat's Common Lisp IDE for Emacs.

SLY is a fork of [[https://slime.common-lisp.dev/][SLIME]]. We tracks its bugfixes, particularly to the
implementation backends. All SLIME's familiar features (debugger,
inspector, xref, etc...) are still available, with improved overall
UX.

#+begin_src emacs-lisp
  (use-package sly
    :mode "\\.lisp\\'")
#+end_src

** Smartparens

Deal with pairs of things with [[https://github.com/Fuco1/smartparens][Smartparens]].

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :commands (smartparens-mode smartparens-strict-mode)
  :config
  (require 'smartparens-config)
  (sp-use-smartparens-bindings))
#+END_SRC

** Smerge

Smerge is a handy tool that helps resolve merge conflicts, however the
default command prefix key binding is rather cumbersome so set it to
something a bit nicer.

Also create a Hydra to make working with Smerge easier.

#+begin_src emacs-lisp
  (use-package smerge-mode
    :ensure nil
    :custom
    (smerge-command-prefix "\C-cv")
    :hook (magit-diff-visit-file . (lambda ()
                                     (when smerge-mode
                                       (smerge-hydra/body)))))
#+end_src

** Spelling

Use ~C-;~ for correcting spelling.

*** iSpell
   
#+begin_src emacs-lisp
  (use-package ispell
    :ensure nil
    :custom
    (ispell-program-name "/opt/homebrew/bin/aspell")
    (ispell-dictionary "en_GB-ise")
    (ispell-personal-dictionary "~/.aspell.en.pws")
    (ispell-extra-args '("--sug-mode=ultra" "--camel-case")))
#+end_src

*** FlySpell

Check my spelling on the fly with [[https://emacsdocs.org/docs/emacs/Spelling][Flyspell]]. Requires `aspell` to be installed.
This also spellchecks spelling in programming mode but only within comments.

#+begin_src emacs-lisp
  (use-package flyspell
    :ensure nil
    :after ispell
    :blackout " Spell"
    :bind (("C-c i b" . flyspell-buffer)
           ("C-c i f" . flyspell-mode))
    :hook ((text-mode . flyspell-mode)
           (org-mode . flyspell-mode))
    :config
    ;; Unbind C-; as it clashes with iedit binding and I mostly use the
    ;; C-. binding for flyspell-correct
    (unbind-key "C-;" flyspell-mode-map))
#+end_src

*** FlySpell-Correct

[[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] - Distraction-free words correction with flyspell via
selected interface.

#+begin_src emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :bind (:map flyspell-mode-map ("C-." . flyspell-correct-wrapper)))
#+end_src

** String Inflection

[[https://github.com/akicho8/string-inflection][string-inflection]] - allows the easy transformation of ~kebab-case~ to
~snake_case~ to ~CamelCase~ and more.

#+begin_src emacs-lisp
  (use-package string-inflection
    :bind ("C-c C-u" . string-inflection-all-cycle))
#+end_src

** Switch-window

Quickly switch between windows with [[https://github.com/dimitri/switch-window][switch-window]].

#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :bind ("C-x o" . switch-window)
  :config
  (setq switch-window-shortcut-style 'qwerty)
  (setq switch-window-qwerty-shortcuts
    '("a" "r" "s" "t" "n" "e" "i" "o"))
  (setq switch-window-threshold 2))
#+END_SRC

** Undo Fu

[[https://gitlab.com/ideasman42/emacs-undo-fu][Undo Fu]] - Simple,
stable linear undo with redo for Emacs via a light weight wrapper for
Emacs built-in undo system,

#+begin_src emacs-lisp
  (use-package undo-fu
    :config
    :bind (("C-/" . undo-fu-only-undo)
           ("C-M-/" . undo-fu-only-redo)))
#+end_src

** Vertico

[[https://github.com/minad/vertico][Vertico]] provides a performant and minimalistic vertical completion UI
based on the default completion system. The main focus of Vertico is
to provide a UI which behaves correctly under all circumstances. By
reusing the built-in facilities system, Vertico achieves full
compatibility with built-in Emacs completion commands and completion
tables.

Note the keybinding being set here to ignore completion suggestions
and just do.  Example of this issue is when trying to create a
directory with dired called java but there is already a javascript
directory, hitting return just uses the completion suggestion so you'd
get an error about how you cannot create the directory as it already
exists.  You can encounter this type of scenario frequently in other
situations too. This Github issue has more details:
[[https://github.com/minad/vertico/issues/211][https://github.com/minad/vertico/issues/211]]. The key binding should be
there by default according to the Github issue but it doesn't seem to
be set for me so I explicitly set it here.  The alternative to using
this binding for ~vertico-exit-input~ would be to use C-p to put the
line back up into the minibuffer text entry line rather than the
completion suggestion.

#+begin_src emacs-lisp
  (use-package vertico
    :bind ("M-<return>" . vertico-exit-input)
    :init
    (vertico-mode)

    ;; Different scroll margin
    ;; (setq vertico-scroll-margin 0)

    ;; Show more candidates
    ;; (setq vertico-count 20)

    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    ;; (setq vertico-cycle t)
    )
#+end_src

Persist history over Emacs restarts. Vertico sorts by history position.

#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :config
    (savehist-mode t))
#+end_src

** Wgrep

[[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]]

wgrep allows you to edit a grep buffer and apply those changes to the
file buffer like sed interactively. No need to learn sed script, just
learn Emacs.

rg.el also integrates with wgrep out of the box.

#+begin_src emacs-lisp
  (use-package wgrep
    :config
    (setq wgrep-auto-save-buffer t))
#+end_src

** Which-key

[[https://github.com/justbur/emacs-which-key][which-key]] is a package that displays available keybindings in popup.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode t)
    :blackout)
#+END_SRC

** Whitespace

[[https://www.emacswiki.org/emacs/WhiteSpace][WhiteSpace]], a mode to toggle visibility of whitespace.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure nil
    :bind ("C-c w" . whitespace-mode)
    :config
    (setq whitespace-line-column 80)
    (setq whitespace-style '(face tabs spaces indentation lines-tail empty trailing)))
#+END_SRC

Automatically cleanup unnecessary whitespace with [[https://github.com/purcell/whitespace-cleanup-mode][whitespace-cleanup-mode]]. 

#+BEGIN_SRC emacs-lisp
  (use-package whitespace-cleanup-mode
    :blackout
    :init
    (global-whitespace-cleanup-mode t)) ; Enabled globally
#+END_SRC

** Xeft

[[https://sr.ht/~casouri/xeft/][Xeft]] -- Fast, incremental note searching in Emacs using [[https://xapian.org/][Xapian]].

#+begin_src emacs-lisp
  (use-package xeft
    :bind ("C-c n x" . xeft)
    :custom
    (xeft-database (expand-file-name "~/.emacs.d/xeft.db"))
    (xeft-default-extension "org")
    (xeft-directory (expand-file-name "~/Documents/notes"))
    (xeft-recursive t))
#+end_src

** YASnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs.

#+begin_src emacs-lisp
  (use-package yasnippet
    :blackout yas-minor-mode
    :config
    (yas-global-mode 1))
#+end_src

[[https://github.com/AndreaCrotti/yasnippet-snippets/][YASnippet-snippets]] the official collection of snippets for many
languages.

#+begin_src emacs-lisp
  (use-package yasnippet-snippets
    :after yasnippet
  )
#+end_src





* Major Modes / Language Specific Stuff
** BASH

#+begin_src emacs-lisp
  (use-package bash-ts-mode
    :ensure nil
    :mode ("\\.sh\\'" . bash-ts-mode))
#+end_src

** C

Similar to JS mode use Smart Tabs for C code and make sure Whitespace
Cleanup doesn't clobber tabs upon save.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (lambda ()
            (setq indent-tabs-mode t)))
#+END_SRC

** Clojure

[[https://github.com/borkdude/clj-kondo/][clj-kondo]] a Clojure linter via flycheck.

#+begin_src emacs-lisp
  (use-package flycheck-clj-kondo)
#+end_src

[[https://github.com/clojure-emacs/clojure-ts-mode][clojure-ts-mode]] - The next generation Clojure major mode for Emacs,
powered by TreeSitter.

#+begin_src emacs-lisp
  (use-package clojure-ts-mode
    :mode (("\\.clj\\'" . clojure-ts-mode)
           ("\\.cljs\\'" . clojure-ts-clojurescript-mode)
           ("\\.cljc\\'" . clojure-ts-clojurec-mode)
           ("\\.bb\\'" . clojure-ts-mode)
           ("\\.boot\\'" . clojure-ts-mode))
    :hook ((clojure-ts-mode . eldoc-mode)
           (clojure-ts-mode . subword-mode)
           (clojure-ts-mode . smartparens-strict-mode))
    :config (require 'flycheck-clj-kondo))
#+end_src

[[https://cider.readthedocs.io/en/latest][CIDER]] is the Clojure(Script) Interactive Development Environment that Rocks!

#+begin_src emacs-lisp
  (use-package cider
    :after clojure-ts-mode
    :commands (cider cider-connect cider-jack-in)
    :bind ("C-c M-j" . cider-jack-in)
    :custom
    (cider-boot-parameters "cider repl -s wait")
    (cider-repl-display-help-banner nil)
    (cider-repl-result-prefix "=> "))
#+end_src

** CSS

#+begin_src emacs-lisp
  (use-package css-mode
    :ensure nil
    :mode ("\\.css\\'" . css-ts-mode))
#+end_src

** Emacs Lisp

#+begin_src emacs-lisp
  (use-package emacs-lisp-mode
    :ensure nil
    :hook (emacs-lisp-mode . smartparens-strict-mode))
#+end_src

** Go

[[https://github.com/dominikh/go-mode.el][Go mode]]

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode ("\\.go\\'" . go-mode)
    :init
    (setq compile-command "go build -v && go test -v"))
#+END_SRC

** JavaScript / TypeScript

#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure nil
    :mode (("\\.ts\\'" . typescript-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode)))
#+end_src

#+begin_src emacs-lisp
  (use-package javascript-mode
    :ensure nil
    :mode (("\\.js\\'" . js-ts-mode)
           ("\\.jsx\\'" . js-ts-mode)))
#+end_src

[[https://github.com/ananthakumaran/tide][Tide]] is the canonical way of using TypeScript within Emacs.

#+begin_src emacs-lisp
  (use-package tide
    :after (typescript-ts-mode flycheck)
    :hook ((typescript-ts-mode . tide-setup)
           (typescript-ts-mode . tide-hl-identifier-mode)))
#+end_src

** Jinja2

[[https://melpa.org/#/jinja2-mode][Jinja2 Mode]] is a major mode for the jinja2 templating language.

#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode
  :mode ("\\.j2\\'" . jinja2-mode))
#+END_SRC

** Just

[[https://github.com/casey/just][Just]] is a command runner that is similar to Make but is a bit nicer to
work with.  This persuades Emacs to use makefile mode for ~justfile~.

#+begin_src emacs-lisp
  (use-package make-mode
    :ensure nil
    :mode (("justfile\\'" . makefile-mode)))
#+end_src

** Markdown

[[http://jblevins.org/projects/markdown-mode/][Markdown Mode]] is a major mode for Markdown offering syntax highlighting
and preview as well as other niceties.

Markdown command is set to [[http://fletcherpenney.net/multimarkdown/][multimarkdown]] so that needs installed on the system.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "pandoc")
    :hook (markdown-mode . markdown-toc-mode))
#+END_SRC

Generate table of contents within Markdown files with [[https://github.com/ardumont/markdown-toc][markdown-toc]].

#+BEGIN_SRC emacs-lisp
  (use-package markdown-toc
    :blackout)
#+END_SRC

** Nix

[[https://github.com/NixOS/nix-mode/][Nix Mode]] -- An Emacs major mode for editing Nix expressions. There is
also a manual available at nix-mode.org.

#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")
#+end_src

** Org

[[http://orgmode.org/][Org mode]] - Your life in plain text.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure nil
    :mode ("\\.org$'" . org-mode)
    :bind (("C-<tab>" . org-cycle-global)
           ("C-c a" . org-agenda)
           ("C-c c" . org-capture)
           ("C-c l" . org-store-link)
           ("C-c C-," . org-insert-structure-template)
           ("C-c C-j" . consult-org-heading))
    :init
    ;; Load extra Org modules from contrib
    (add-to-list 'org-modules 'org-protocol)
    (add-to-list 'org-modules 'org-crypt)
    (add-to-list 'org-modules 'ox-beamer)

    :custom
    (org-goto-interface 'outline-path-completion)
    (org-goto-max-level 3)

    :config
    (setq org-ellipsis " » " ;; folding symbol
          org-pretty-entities t
          org-hide-emphasis-markers t
          ;; show actually italicized text instead of /italicized text/
          org-agenda-block-separator ""
          org-fontify-whole-heading-line t
          org-fontify-done-headline t
          org-fontify-quote-and-verse-blocks t)

    (setq org-latex-compiler "xelatex")

    ;; Syntax highlight code blocks and make tabs work as expected.
    (setq org-src-fontify-natively t
          org-src-tab-acts-natively t)

    (setq org-directory (expand-file-name "~/Documents/notes"))
    (setq org-default-notes-file (concat org-directory "/capture.org"))
    (setq org-log-done 'time)
    (setq org-log-done-with-time t)
    (setq org-log-into-drawer t)
    (setq org-completion-use-ido t)

    ;; Follow links with RET.
    (setq org-return-follows-link t)

    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELLED(c@)")))

    ;; Set active Org Babel languages
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((clojure    . t)
       (css        . t)
       (emacs-lisp . t)
       (java       . t)
       (js         . t)
       (makefile   . t)
       (org        . t)
       (python     . t)
       (ruby       . t)
       (shell      . t)
       (sql        . t)))

    ;; Capture templates
    (setq org-capture-templates
          `(("c" "Quick Capture" entry (file ,(concat org-directory "/capture.org"))
             "* %?\nCaptured on %U\n  %i\n" :empty-lines 1)
            ("n" "New note (with Denote)" plain
             (file denote-last-path)
             #'denote-org-capture
             :no-save t
             :immediate-finish nil
             :kill-buffer t
             :jump-to-captured t)
            ("j" "Journal entry" entry (function org-journal-find-location)
             "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?" :empty-lines 1)
            ("t" "Todo" entry (file+headline ,(concat org-directory "/todo.org") "Inbox")
             "* TODO %?\n  %i\n" :empty-lines 1)
            ("s" "Someday / Maybe" entry (file+headline ,(concat org-directory "/someday-maybe.org") "Inbox")
             "* TODO %?\n  %i\n" :empty-lines 1)))

    ;; Refile targets
    (setq org-refile-targets
          '(("todo.org" :maxlevel . 3)
            ("someday-maybe.org" :maxlevel . 3)
            ("links.org" :maxlevel . 3)
            ("cal.org" :maxlevel . 3)))

    ;; https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html
    ;; Show full path for refile targets.
    (setq org-refile-use-outline-path t)

    ;; This option is also needed for the full path stuff to work,
    ;; without it you just get lots of repeated file names in the Ivy
    ;; selection window.  Full details in the blog post linked above.
    (setq org-outline-path-complete-in-steps nil)

    ;; Allow refiling to a new parent heading.
    (setq org-refile-allow-creating-parent-nodes 'confirm)

    ;; Custom function to quickly archive all done tasks.
    (defun rt/org-archive-done-tasks ()
      "Archive tasks that are done."
      (interactive)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
       "/DONE" 'tree)
      ;; I'm sure this could be done better as part of the
      ;; org-map-entries function above but I'm not sure how so just
      ;; repeat for cancelled tasks.
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
       "/CANCELLED" 'tree))


    ;; org-agenda
    (setq org-agenda-files '((concat org-directory "/todo.org")
                             (concat org-directory "/someday-maybe.org")
                             (concat org-directory "/cal.org"))
          org-agenda-skip-deadline-if-done t
          org-agenda-skip-scheduled-if-done t)

    ;; org-crypt
    (org-crypt-use-before-save-magic)
    (setq org-tags-exclude-from-inheritance (quote ("crypt")))

    ;; imenu
    (setq org-imenu-depth 4)

    ;; GPG key to use for encryption
    ;; Either the Key ID or set to nil to use symmetric encryption.
    (setq org-crypt-key "0x4799AD5040FF28FB5F3D71D7667A3481E4BB34F3"))
#+END_SRC

*** Org AI

#+begin_src emacs-lisp
  (use-package org-ai
    :blackout
    :config
    (org-ai-global-mode)
    (setq org-ai-image-directory (expand-file-name "~/Documents/notes/org-ai-images/"))
    :hook (org-mode . org-ai-mode))
#+end_src

*** Org Citar

[[https://github.com/emacs-citar/citar][Citar]] is an Emacs package to quickly find and act on bibliographic
references, and edit org, markdown, and latex academic documents.

#+begin_src emacs-lisp
  (use-package citar
    :custom
    (citar-bibliography '("~/Documents/notes/references.bib"))
    :hook
    (LaTeX-mode . citar-capf-setup)
    (org-mode . citar-capf-setup))
#+end_src

[[https://github.com/pprevos/citar-denote/][citar-denote]] is an Emacs package to create and retrieve bibliography
notes with the Citar and Denote packages.

#+begin_src emacs-lisp
  (use-package citar-denote
    :after citar denote
    :blackout
    :config (citar-denote-mode))
#+end_src

The [[https://github.com/emacs-citar/citar#embark][citar-embark]] package adds contextual access actions in the
minibuffer and at-point via the citar-embark-mode minor mode.

#+begin_src emacs-lisp
  (use-package citar-embark
    :after citar embark
    :no-require
    :config (citar-embark-mode))
#+end_src

*** Org Contacts

[[https://repo.or.cz/org-contacts.git][org-contacts.el]] - is a contacts management system for Org Mode.

#+begin_src emacs-lisp
  (use-package org-contacts
    :ensure (org-contacts :host "repo.or.cz" :repo "org-contacts" :main "org-contacts.el"))
#+end_src

*** Org CV

#+begin_src emacs-lisp
  (use-package ox-awesomecv
    :ensure (ox-awesomecv :host gitlab :repo "Titan-C/org-cv")
    :init (require 'ox-awesomecv)
    :config
    (defun rt/compile-cv ()
      "Compile CV with LaTeX."
      (interactive)
      (org-export-to-file 'awesomecv "rosstimson-cv.tex")
      (org-latex-compile "rosstimson-cv.tex")))
#+end_src

*** Org Download

[[https://github.com/abo-abo/org-download][org-download]] - Drag and drop images to Emacs org-mode.

#+begin_src emacs-lisp
  (use-package org-download
    :after org
    :bind (:map org-mode-map
                ("C-c C-x C" . org-download-clipboard)
                ("C-c C-x Y" . org-download-yank))
    :custom
    (org-download-method 'directory)
    (org-download-screenshot-method "screencapture -i %s")
    (org-download-heading-lvl 1)
    (org-download-image-dir "./img"))
#+end_src

*** Org Journal

#+begin_src emacs-lisp
  (use-package org-journal
    :after org
    :bind ("C-c j" . org-journal-new-entry)
    :custom
    (org-journal-file-type 'monthly)
    (org-journal-date-format "%A, %d %B %Y")
    (org-journal-dir (concat (concat org-directory "/journal/") (format-time-string "%Y"))))
#+end_src

*** Org Modern

[[https://github.com/minad/org-modern][Org Modern Style]] - 🦄 This package implements a modern style for your
Org buffers using font locking and text properties.

#+begin_src emacs-lisp
  (use-package org-modern
    :after org
    :config
    (global-org-modern-mode))
#+end_src

*** Org Remark

[[https://nobiot.github.io/org-remark/#Installation][Org-remark]] lets you highlight and annotate text files, websites, and
EPUB books with using Org mode.

#+begin_src emacs-lisp
  (use-package org-remark
    :after org
    :commands (org-remark-global-tracking-mode)
    :bind (:map org-mode-map
                ("C-c C-x R" . org-remark-mode))
    :config
    (org-remark-global-tracking-mode t)
    :custom
    (org-remark-notes-file-name 'org-remark-notes-file-name-function))
#+end_src

*** Org Transclusion

[[https://github.com/nobiot/org-transclusion#installation][Org-transclusion]] lets you insert a copy of text content via a file
link or ID link within an Org file. It lets you have the same content
present in different buffers at the same time without copy-and-pasting
it. Edit the source of the content, and you can refresh the
transcluded copies to the up-to-date state. Org-transclusion keeps
your files clear of the transcluded copies, leaving only the links to
the original content.<<whatis>>

#+begin_src emacs-lisp
  (use-package org-transclusion
    :after org
    :bind ("C-c t" . org-transclusion-add))
#+end_src

*** Org Web Tools

[[https://github.com/alphapapa/org-web-tools][org-web-tools]] contains library functions and commands useful for
retrieving web page content and processing it into Org-mode content.

For example, you can copy a URL to the clipboard or kill-ring, then
run a command that downloads the page, isolates the “readable” content
with eww-readable, converts it to Org-mode content with Pandoc, and
displays it in an Org-mode buffer. Another command does all of that
but inserts it as an Org entry instead of displaying it in a new
buffer.

#+begin_src emacs-lisp
  (use-package org-web-tools
    :after org
    :commands (org-web-tools-insert-link-for-url
               org-web-tools-insert-web-page-as-entry
               org-web-tools-read-url-as-org
               org-web-tools-convert-links-to-page-entries))
#+end_src

** Python

Setup Python mode

#+BEGIN_SRC emacs-lisp
(use-package python
  :mode ("\\.py\\'" . python-ts-mode)
  :interpreter ("python" . python-ts-mode)
  :config
  (setq fill-column 79)
  (setq python-check-command "flake8")
  (setq tab-width 4))
#+END_SRC

[[https://github.com/proofit404/anaconda-mode][Anaconde mode]] offers code navigation, documentation lookup, and completion
for Python.

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :init
  (progn
    (add-hook 'python-ts-mode-hook 'anaconda-mode)
    (add-hook 'python-ts-mode-hook 'anaconda-eldoc-mode)))
#+END_SRC

Virtual envs with [[https://python-poetry.org/][Poetry]] / [[https://github.com/cybniv/poetry.el][poetry.el]]

#+begin_src emacs-lisp
  (use-package poetry
    :hook
    ;; activate poetry-tracking-mode when python-mode is active
    (python-ts-mode . poetry-tracking-mode))
#+end_src

** RestClient

Mode for working with REST APIs.

#+begin_src emacs-lisp
(use-package restclient
  :mode ("\\.http\\'" . restclient-mode))
#+end_src

** Rust

[[https://github.com/rust-lang/rust-mode][Rust-mode]] -- A major mode for Rust.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode ("\\.rs\\'" . rust-mode)
    :config
    (setq rust-format-on-save t))
#+END_SRC

[[https://github.com/kwrooijen/cargo.el][Cargo.el]] -- A minor mode for Cargo the Rust build tool, it adds some
convenient bindings for running Cargo commands.

#+begin_src emacs-lisp
  (use-package cargo
    :hook (rust-mode . cargo-minor-mode))
#+end_src

** Shell

Use tabs in shell scripts otherwise heredoc functionality around
whitespace can be weird.

#+BEGIN_SRC emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            (setq indent-tabs-mode t)))
#+END_SRC

** Terraform

[[https://github.com/syohex/emacs-terraform-mode][Terraform Mode]] is a major mode for editing Terraform files.

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
    :config
    (setq terraform-indent-level 2))
#+END_SRC

** Web Mode

[[http://web-mode.org/][Web-mode]] for editing web templates -- can syntax highlight
appropriately for embedded CSS or JavaScript.

#+begin_src emacs-lisp
  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.css\\'" . web-mode)
           ("\\.j2\\'" . web-mode))
    :init
    ;; Astro - https://astro.build
    (define-derived-mode astro-mode web-mode "astro"
      "A major mode derived from web-mode, for editing .astro files with LSP support.")

    ;; Vue - https://vuejs.org
    (define-derived-mode vue-mode web-mode "vue"
      "A major mode derived from web-mode, for editing .vue files with LSP support.")

    (setq auto-mode-alist
          (append '((".*\\.astro\\'" . astro-mode)
                    ("\\.vue\\'" . vue-mode))
                  auto-mode-alist))

    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-enable-auto-pairing t
          web-mode-enable-auto-expanding t
          web-mode-enable-css-colorization t
          web-mode-enable-current-element-highlight t
          web-mode-enable-current-column-highlight t
          web-mode-engines-alist '(("jinja2" . "\\.j2\\'"))))
#+end_src

** YAML

[[https://www.emacswiki.org/emacs/YamlMode][Yaml mode]]

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode (("\\.yml$" . yaml-mode)
         ("\\.yaml$" . yaml-mode)
         ("\\.sls$" . yaml-mode))) ; SaltStack
#+END_SRC


* Extras
** Ediff


#+begin_src emacs-lisp
(use-package ediff
  :ensure nil
  :config
  ;; Use the selected frame for ediff rather that a new one.
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Split window into vertical panes, better for wider screens.
  (setq ediff-split-window-function 'split-window-horizontally)

  ;; expand everything that can be expanded before ediffing
  ;; this is useful for org-mode and code folding
  :hook (ediff-prepare-buffer . outline-show-all))
#+end_src

** Email / mu4e

[[https://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] - Emacs-based e-mail client which uses mu as its back-end: mu4e.

#+begin_src emacs-lisp
  (use-package mu4e
    :ensure nil
    :load-path "/opt/homebrew/share/emacs/site-lisp/mu/mu4e"
    :commands (mu4e mu4e-compose-new)
    :config
    (setq mu4e-get-mail-command (concat (executable-find "mbsync") " -a")
          mu4e-update-interval 600 ;; In seconds = 10 mins
          mu4e-sent-folder "/Sent Messages"
          mu4e-drafts-folder "/Drafts"
          mu4e-trash-folder "/Deleted Messages"
          mu4e-refile-folder "/Archive"
          mu4e-maildir-shortcuts
          '((:maildir "/INBOX"             :key  ?i)
            (:maildir "/Archive"           :key  ?a)
            (:maildir "/@Action"           :key  ?t)
            (:maildir "/@Waiting"          :key  ?w)
            (:maildir "/Sent Messages"     :key  ?s))))
#+end_src

** Sqlite3

[[https://github.com/pekingduck/emacs-sqlite3-api][sqlite3]] is a dynamic module for GNU Emacs 25+ that provides direct
access to the core SQLite3 C API from Emacs Lisp.

#+begin_src emacs-lisp
  (use-package sqlite3)
#+end_src
